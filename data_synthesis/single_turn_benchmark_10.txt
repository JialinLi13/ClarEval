{"header": {"task_id": "task1_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data should the function process?", "dimension": "Why"}, {"description": "What is the expected result or output of the function?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'has_close_elements'.", "dimension": "What"}, {"description": "The function should take a list of floats and a float threshold as parameters.", "dimension": "What"}, {"description": "The function should return a boolean indicating if any two numbers in the list are closer than the threshold.", "dimension": "What"}, {"description": "The function should include examples in the docstring to illustrate its usage.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task1_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function signature details", "Input/output format"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What is the specific purpose of the function in terms of the relationship between the input elements?", "dimension": "Why"}, {"description": "What should the function return if the input list is empty or contains only one element?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a list of floats and a float threshold as inputs.", "dimension": "What"}, {"description": "The function should return a boolean indicating if any two numbers in the list are closer than the given threshold.", "dimension": "What"}, {"description": "The function should compare each pair of numbers in the list to determine if their difference is less than the threshold.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task1_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and returns a result", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["function signature", "generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of input should the function accept?", "dimension": "Why"}, {"description": "What specific condition should the function check for in the input?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should accept a list of floats and a float threshold as inputs.", "dimension": "What"}, {"description": "The function should return a boolean indicating if any two numbers in the list are closer than the threshold.", "dimension": "What"}, {"description": "The function should be named 'has_close_elements'.", "dimension": "What"}, {"description": "The function should include example usage in the docstring for clarity.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Can you provide more details on what the function should do?", "common_mistakes": ["assuming the function signature is missing", "misinterpreting 'generate' as creating something visually"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach is straightforward and focuses on understanding the function's purpose rather than technical details", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task2_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of data manipulation is required for the function?", "dimension": "Why"}, {"description": "What is the expected format of the result after data manipulation?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function signature should be separate_paren_groups(paren_string: str) -> List[str]", "dimension": "What"}, {"description": "The input string contains multiple groups of nested parentheses that need to be separated into balanced groups.", "dimension": "What"}, {"description": "Spaces in the input string should be ignored during processing.", "dimension": "What"}, {"description": "The output should be a list of strings, each representing a separate group of balanced parentheses.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n"}
{"header": {"task_id": "task2_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Data format", "Parameter details"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What is the specific structure of the input string that the function should handle?", "dimension": "Why"}, {"description": "How should the function handle spaces within the input string?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a single string input containing multiple groups of nested parentheses.", "dimension": "What"}, {"description": "The function should return a list of strings, each representing a separate group of balanced parentheses.", "dimension": "What"}, {"description": "The input string may contain spaces which should be ignored when processing the parentheses groups.", "dimension": "What"}, {"description": "Each group of parentheses in the input is balanced and not nested within each other.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n"}
{"header": {"task_id": "task2_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output based on certain rules.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["Function signature", "Generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific rules should be applied to determine how the input is processed into the output?", "dimension": "Why"}, {"description": "What is the expected format of the output, and how should the function handle edge cases?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a string containing multiple groups of nested parentheses as input.", "dimension": "What"}, {"description": "The function should return a list of strings, each representing a separate group of balanced parentheses.", "dimension": "What"}, {"description": "The input string may contain spaces, which should be ignored when processing the parentheses groups.", "dimension": "What"}, {"description": "Each group of parentheses in the input is balanced and not nested within each other.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on the input and output requirements of the function?", "common_mistakes": ["Assuming the function signature is a specific format", "Misinterpreting the term 'generate'"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the function's purpose rather than specific technical terms.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n"}
{"header": {"task_id": "task3_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance optimization", "input validation"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data should the function process, and what specific result is expected?", "dimension": "Why"}, {"description": "Should the function handle any specific edge cases or types of input beyond positive floating point numbers?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a positive floating point number as input.", "dimension": "What"}, {"description": "The function should return the decimal part of the number.", "dimension": "What"}, {"description": "The integer part of the number is defined as the largest integer smaller than the given number.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n"}
{"header": {"task_id": "task3_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function name", "Input parameter type"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific part of the input number should the function return?", "dimension": "Why"}, {"description": "Should the function handle only positive floating point numbers or other types as well?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a positive floating point number as input.", "dimension": "What"}, {"description": "The function should return the decimal part of the number.", "dimension": "What"}, {"description": "The integer part of the number is the largest integer smaller than the given number.", "dimension": "What"}, {"description": "The function should be named 'truncate_number'.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n"}
{"header": {"task_id": "task3_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes a collection of items and returns a modified version of the collection.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["Function signature", "Generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of collection should the function handle (e.g., list, set, tuple)?", "dimension": "Why"}, {"description": "What kind of modification is expected on the collection (e.g., filtering, mapping)?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a positive floating point number as input.", "dimension": "What"}, {"description": "The function should return the decimal part of the number.", "dimension": "What"}, {"description": "The function should decompose the number into an integer part and a decimal part.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on what the function should do and what type of items it will be working with?", "common_mistakes": ["Assuming the function signature is a specific format", "Not asking for clarification on the type of modification needed"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the function's purpose and input/output requirements, reducing the need for technical terminology clarification.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n"}
{"header": {"task_id": "task4_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data manipulation is required and what is the expected result?", "dimension": "Why"}, {"description": "What specific conditions should trigger a return value of True or False?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'below_zero'.", "dimension": "What"}, {"description": "The function should take a list of integers as input, representing deposit and withdrawal operations.", "dimension": "What"}, {"description": "The function should return True if the balance falls below zero at any point, otherwise False.", "dimension": "What"}, {"description": "The initial balance of the account is zero.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task4_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function name", "Input parameter type"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of operations should the function handle (e.g., deposits, withdrawals)?", "dimension": "Why"}, {"description": "What should the function return if the balance never falls below zero?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a list of integers as input, representing deposit and withdrawal operations.", "dimension": "What"}, {"description": "The function should return a boolean value indicating if the balance falls below zero at any point.", "dimension": "What"}, {"description": "The initial balance of the account is zero.", "dimension": "What"}, {"description": "The function should return True if the balance falls below zero at any point, otherwise False.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task4_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output based on certain conditions.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["Function signature", "Generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific conditions should the function check to determine the output?", "dimension": "Why"}, {"description": "What is the expected behavior of the function when the balance falls below zero?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should take a list of integers representing deposit and withdrawal operations.", "dimension": "What"}, {"description": "The function should return True if the balance falls below zero at any point, otherwise False.", "dimension": "What"}, {"description": "The account starts with a zero balance.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Can you provide more details on the input and output requirements for the function?", "common_mistakes": ["Assuming the function signature is a specific format", "Not asking for clarification on the generation process"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the requirements without getting bogged down in technical terms.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n"}
{"header": {"task_id": "task5_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of data should the function process?", "dimension": "Why"}, {"description": "What is the expected result or output format of the function?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should calculate the Mean Absolute Deviation for a list of numbers.", "dimension": "What"}, {"description": "The input to the function should be a list of floats.", "dimension": "What"}, {"description": "The function should return a float representing the Mean Absolute Deviation.", "dimension": "What"}, {"description": "The Mean Absolute Deviation is calculated as the average absolute difference between each element and the mean of the dataset.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n"}
{"header": {"task_id": "task5_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and returns the result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Data format", "Parameter details"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific calculation or operation should the function perform on the input?", "dimension": "Why"}, {"description": "What is the expected type and structure of the input data?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should calculate the Mean Absolute Deviation of a list of numbers.", "dimension": "What"}, {"description": "The input should be a list of floats.", "dimension": "What"}, {"description": "The function should return a float representing the Mean Absolute Deviation.", "dimension": "What"}, {"description": "The formula for Mean Absolute Deviation is the average of the absolute differences between each element and the mean of the list.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n"}
{"header": {"task_id": "task5_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output based on certain conditions.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["function signature", "generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific conditions should the function consider when processing the input?", "dimension": "Why"}, {"description": "What is the expected behavior or output format of the function?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should calculate the Mean Absolute Deviation of a list of numbers.", "dimension": "What"}, {"description": "The input to the function is a list of floats.", "dimension": "What"}, {"description": "The function should return a float representing the Mean Absolute Deviation.", "dimension": "What"}, {"description": "The Mean Absolute Deviation is calculated as the average of the absolute differences between each element and the mean of the list.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on what the function should do and what the input/output should be?", "common_mistakes": ["Assuming the function signature is a specific format", "Misinterpreting the term 'generate'"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach is straightforward and focuses on understanding the task requirements without overwhelming the user with technical jargon.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n"}
{"header": {"task_id": "task6_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data should the function process, and what is the expected result format?", "dimension": "Why"}, {"description": "Is there a specific operation or transformation that should be applied to the data?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'intersperse'.", "dimension": "What"}, {"description": "The function should take two parameters: a list of integers 'numbers' and an integer 'delimeter'.", "dimension": "What"}, {"description": "The function should insert the 'delimeter' between every two consecutive elements of the list 'numbers'.", "dimension": "What"}, {"description": "The function should return a new list with the 'delimeter' interspersed between elements.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task6_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function signature details", "Data manipulation specifics"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of data manipulation is required for the function?", "dimension": "Why"}, {"description": "Should the function handle any specific edge cases or input constraints?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'intersperse'.", "dimension": "What"}, {"description": "The function should take two parameters: a list of integers and a delimiter integer.", "dimension": "What"}, {"description": "The function should return a new list with the delimiter inserted between every two consecutive elements of the input list.", "dimension": "What"}, {"description": "The function should handle an empty list input by returning an empty list.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task6_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["function signature", "generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What is the specific purpose of the function to be created?", "dimension": "Why"}, {"description": "What should the function do with the input to produce the desired output?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'intersperse'.", "dimension": "What"}, {"description": "The function should take two parameters: a list of integers and a delimiter integer.", "dimension": "What"}, {"description": "The function should insert the delimiter between every two consecutive elements of the input list.", "dimension": "What"}, {"description": "The function should return a new list with the delimiter inserted.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Can you provide more details on what the function should do?", "common_mistakes": ["assuming the function signature is a specific format", "misinterpreting 'generate' as creating something visually"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach is straightforward and focuses on understanding the function's purpose rather than technical details", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task7_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data should the function process?", "dimension": "Why"}, {"description": "What specific result is expected from processing the data?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'parse_nested_parens'.", "dimension": "What"}, {"description": "The input is a string with multiple groups of nested parentheses separated by spaces.", "dimension": "What"}, {"description": "The function should return a list of integers representing the deepest level of nesting for each group.", "dimension": "What"}, {"description": "Example input and output: '(()()) ((())) () ((())()())' should return [2, 3, 1, 3].", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task7_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function signature details", "Input/output data format"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What is the specific input format expected for the function?", "dimension": "Why"}, {"description": "What should the function return for each group of parentheses?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'parse_nested_parens'.", "dimension": "What"}, {"description": "The input is a string with multiple groups of nested parentheses separated by spaces.", "dimension": "What"}, {"description": "The function should return a list of integers representing the deepest level of nesting for each group.", "dimension": "What"}, {"description": "Example input and output: '(()()) ((())) () ((())()())' should return [2, 3, 1, 3].", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task7_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "string_processing"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and returns a result", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["function signature", "generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What is the specific input format and expected output for the function?", "dimension": "Why"}, {"description": "What is the purpose of calculating the deepest level of nesting in parentheses?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'parse_nested_parens'.", "dimension": "What"}, {"description": "The input is a string with multiple groups of nested parentheses separated by spaces.", "dimension": "What"}, {"description": "The output should be a list of integers representing the deepest level of nesting for each group.", "dimension": "What"}, {"description": "Example input and output: '(()()) ((())) () ((())()())' should return [2, 3, 1, 3].", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Can you provide more details on what the function should do?", "common_mistakes": ["assuming the function signature is a specific format", "misinterpreting 'generate' as creating something visually"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach is straightforward and focuses on understanding the function's purpose rather than technical details", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n"}
{"header": {"task_id": "task8_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "data_structure"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of data manipulation is required?", "dimension": "Why"}, {"description": "What should the function return after manipulating the data?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should filter a list of strings based on the presence of a given substring.", "dimension": "What"}, {"description": "The function signature should be filter_by_substring(strings: List[str], substring: str) -> List[str].", "dimension": "What"}, {"description": "The function should return a list of strings that contain the specified substring.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n"}
{"header": {"task_id": "task8_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "data_structure"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Function signature details", "Data manipulation specifics"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of data manipulation is required?", "dimension": "Why"}, {"description": "What is the expected output format after data manipulation?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should filter a list of strings based on the presence of a given substring.", "dimension": "What"}, {"description": "The function signature should be filter_by_substring(strings: List[str], substring: str) -> List[str].", "dimension": "What"}, {"description": "The function should return a list of strings that contain the specified substring.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n"}
{"header": {"task_id": "task8_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "data_structure"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and returns a result", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["function signature", "generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of input should the function accept?", "dimension": "Why"}, {"description": "What specific criteria should be used to determine the result?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'filter_by_substring'.", "dimension": "What"}, {"description": "The function should accept a list of strings and a substring as parameters.", "dimension": "What"}, {"description": "The function should return a list of strings that contain the given substring.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on what the function should do and what the input and output should be?", "common_mistakes": ["assuming the function signature is a specific format", "misinterpreting 'generate' as creating something visually"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the core functionality of the task without getting caught up in specific technical terms.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n"}
{"header": {"task_id": "task9_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that manipulates data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific data manipulation is required by the function?", "dimension": "Why"}, {"description": "What should the function return after manipulating the data?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'sum_product'.", "dimension": "What"}, {"description": "The function should take a list of integers as input.", "dimension": "What"}, {"description": "The function should return a tuple consisting of the sum and product of the integers.", "dimension": "What"}, {"description": "The sum of an empty list should be 0 and the product should be 1.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n"}
{"header": {"task_id": "task9_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input data and performs a transformation on it.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Data format", "Transformation details"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific transformation should be applied to the input data?", "dimension": "Why"}, {"description": "What is the expected output format after the transformation?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should return a tuple consisting of the sum and product of the integers.", "dimension": "What"}, {"description": "The sum of an empty list should be 0.", "dimension": "What"}, {"description": "The product of an empty list should be 1.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n"}
{"header": {"task_id": "task9_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output based on certain rules.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["Function signature", "Generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific rules should the function follow to transform the input into the output?", "dimension": "Why"}, {"description": "What is the expected behavior of the function when the input list is empty?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should return a tuple consisting of the sum and product of all integers in the list.", "dimension": "What"}, {"description": "The sum of an empty list should be 0.", "dimension": "What"}, {"description": "The product of an empty list should be 1.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on the input and output requirements of the function?", "common_mistakes": ["Assuming the function signature is a specific format", "Misinterpreting the term 'generate'"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the function's purpose rather than specific technical terms.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n"}
{"header": {"task_id": "task10_missing_goal", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Goal", "difficulty": "medium", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that processes data and returns a result.", "ambiguity_details": {"missing_goal": ["performance", "boundary conditions"], "missing_premises": [], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.2, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What type of data should the function process?", "dimension": "Why"}, {"description": "What specific result is expected from the function?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'rolling_max'.", "dimension": "What"}, {"description": "The function should take a list of integers as input.", "dimension": "What"}, {"description": "The function should return a list of rolling maximums from the input list.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n"}
{"header": {"task_id": "task10_missing_premises", "source_dataset": "HumanEvalComm", "fuzzy_type": "Missing Premises", "difficulty": "hard", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes input and outputs a result.", "ambiguity_details": {"missing_goal": [], "missing_premises": ["Data format", "Parameter details"], "ambiguous_terms": []}, "injection_quality": {"clarity_score": 0.3, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific type of input should the function handle?", "dimension": "Why"}, {"description": "What is the expected behavior of the function in terms of output?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'rolling_max'.", "dimension": "What"}, {"description": "The function should take a list of integers as input.", "dimension": "What"}, {"description": "The function should return a list of integers representing the rolling maximum.", "dimension": "What"}, {"description": "The function should follow the example provided in the docstring for expected output.", "dimension": "What"}], "interaction_guidelines": {}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n"}
{"header": {"task_id": "task10_ambiguous_terms", "source_dataset": "HumanEvalComm", "fuzzy_type": "Ambiguous Terms", "difficulty": "easy", "domain": "general"}, "original": {"description": "", "function_signature": "function_signature_not_found", "test_cases": []}, "fuzzy_version": {"instruction": "Create a function that takes an input and produces an output based on certain conditions.", "ambiguity_details": {"missing_goal": [], "missing_premises": [], "ambiguous_terms": ["Function signature", "Generate"]}, "injection_quality": {"clarity_score": 0.6000000000000001, "recoverability": true}}, "evaluation_criteria": {"key_intent_set": [{"description": "What specific conditions should the function consider when producing the output?", "dimension": "Why"}, {"description": "Is the function supposed to handle only integer inputs or should it accommodate other data types?", "dimension": "Why"}], "ground_truth_missing_premises": [{"description": "The function should be named 'rolling_max'.", "dimension": "What"}, {"description": "The function should take a list of integers as input.", "dimension": "What"}, {"description": "The function should return a list of rolling maximums from the input list.", "dimension": "What"}, {"description": "The function should follow the example provided in the docstring for expected behavior.", "dimension": "What"}], "interaction_guidelines": {"ideal_question_style": "Could you provide more details on the input and output requirements for the function?", "common_mistakes": ["Assuming the function signature is a specific format", "Not asking for clarification on the conditions"], "cognitive_load_score": 0.7, "why_low_cognitive_load": "This questioning approach focuses on understanding the function's purpose and requirements without getting caught up in specific technical terms.", "dimension": "How"}}, "ground_truth_solution": "", "original_prompt_source": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n"}
